# -*- coding: utf-8 -*-
"""Zidio Project Data Analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UGKywfkvYAW5dIBpftdd5ofz8YKnuaSb
"""

import pandas as pd

df = pd.read_csv('stock market.csv')

from google.colab import drive
drive.mount('/content/drive')

print("Before Cleaning:")
print(df.info())

print(df.head())

#clean the data


# Convert 'Date' column to datetime
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')

# Drop rows where 'Date' is NaT (conversion failed)
df = df.dropna(subset=['Date'])

# Fill missing values in 'Trades' column with the median
if 'Trades' in df.columns:
    df['Trades'] = df['Trades'].fillna(df['Trades'].median())

# Remove duplicate rows
df = df.drop_duplicates()

# Reset index
df = df.reset_index(drop=True)

print("\nAfter Cleaning:")
print(df.info())
print(df.head())

import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

plt.figure(figsize=(12,6))
plt.plot(df['Date'], df['Close'], label='Close Price')
plt.title('Stock Closing Prices Over Time')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,6))
plt.plot(df['Date'], df['Volume'], color='orange', label='Volume Traded')
plt.title('Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(10,6))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap='coolwarm')
plt.title('Correlation Between Variables')
plt.show()

plt.figure(figsize=(10,6))
sns.boxplot(data=df[['Open', 'High', 'Low', 'Close']])
plt.title('Boxplot of Stock Prices')
plt.show()

import plotly.graph_objects as go

fig = go.Figure(data=[go.Candlestick(x=df['Date'],
                open=df['Open'],
                high=df['High'],
                low=df['Low'],
                close=df['Close'])])
fig.update_layout(title='Candlestick Chart', xaxis_title='Date', yaxis_title='Price')
fig.show()

df['Daily Return'] = df['Close'].pct_change()
plt.figure(figsize=(10,6))
sns.histplot(df['Daily Return'].dropna(), bins=50, kde=True)
plt.title('Distribution of Daily Returns')
plt.xlabel('Daily Return')
plt.show()



"""ARIMA, SARIMA

✅ Step-by-Step Plan for Time Series Forecasting
Step 1: Filter & Sort the Time Series
"""

df = df[df['Symbol'] == 'MUNDRAPORT']  # If only one stock
df = df[['Date', 'Close']].sort_values('Date')
df.set_index('Date', inplace=True)

"""Step 2: Visualize the Data"""

import matplotlib.pyplot as plt

df['Close'].plot(figsize=(12, 4), title='Closing Price Over Time')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.show()

"""Step 3: Test for Stationarity
Use the Augmented Dickey-Fuller (ADF) test:
"""

from statsmodels.tsa.stattools import adfuller

result = adfuller(df['Close'])
print(f'p-value: {result[1]}')  # p < 0.05 means stationary

"""Step 4: Plot ACF and PACF to Find Parameters"""

import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# First-order differencing to remove trend
df_diff = df['Close'].diff().dropna()

# Plot ACF and PACF
plot_acf(df_diff, lags=30)
plt.title("Autocorrelation (ACF)")
plt.show()

plot_pacf(df_diff, lags=30)
plt.title("Partial Autocorrelation (PACF)")
plt.show()

"""Step 5: Fit ARIMA Model"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA

# Check stationarity
result = adfuller(df['Close'])
print(f"ADF Statistic: {result[0]}")
print(f"p-value: {result[1]}")  # < 0.05 = stationary

df_diff = df['Close'].diff().dropna()

result_diff = adfuller(df_diff)
print(f"ADF Statistic (Differenced): {result_diff[0]}")
print(f"p-value (Differenced): {result_diff[1]}")

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt

plot_acf(df_diff, lags=30)
plot_pacf(df_diff, lags=30)
plt.show()

plot_acf(df_diff, lags=30)
plot_pacf(df_diff, lags=30)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Load your data
df = pd.read_csv('stock market.csv')

# Filter and preprocess
df = df[df['Symbol'] == 'MUNDRAPORT']
df = df[['Date', 'Close']].sort_values('Date')
df['Date'] = pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)
df = df.asfreq('D')  # Set frequency to daily

# Fill missing values if any (to prevent model failure)
df['Close'] = df['Close'].interpolate()

# Check stationarity
result = adfuller(df['Close'])
print(f'ADF Statistic: {result[0]}')
print(f'p-value: {result[1]}')

# Fit ARIMA model
model = ARIMA(df['Close'], order=(1, 1, 1))
model_fit = model.fit()

# Summary
print(model_fit.summary())

# Forecast 30 days
forecast = model_fit.forecast(steps=30)

# Plot forecast
plt.figure(figsize=(10, 4))
plt.plot(df['Close'], label='Historical')
plt.plot(pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=30),
         forecast, label='Forecast', color='red')
plt.title('30-Day ARIMA Forecast')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

"""✅ Step-by-Step SARIMA Setup
Step 1: Set your index to Date (with frequency)
"""

print(df.index)

df.index = pd.DatetimeIndex(df.index)
df.index = df.index.to_period('D')

from statsmodels.tsa.statespace.sarimax import SARIMAX

model = SARIMAX(df['Close'],
                order=(1, 1, 1),
                seasonal_order=(1, 1, 1, 7))  # Weekly seasonality

model_fit = model.fit()
print(model_fit.summary())

"""Forecast future values"""

forecast = model_fit.get_forecast(steps=30)
forecast_df = forecast.conf_int()
forecast_df['Forecast'] = forecast.predicted_mean

forecast_df[['Forecast']].plot(title="30-Day Forecast")

"""**Prophet Forecast (using Prophet to predict future)**"""

from prophet import Prophet
import matplotlib.pyplot as plt

df.head()

# reset index of Date
df_prophet=df.reset_index()[['Date','Close']]

# Rename the columns in prophet model format
df_prophet.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)
df_prophet['ds'] = df_prophet['ds'].dt.to_timestamp()

df_prophet.head()
df_prophet.info()

# fit the prophet model
model_prophet=Prophet()
model_prophet.fit(df_prophet)

future = model_prophet.make_future_dataframe(periods=365)
forecast_prophet = model_prophet.predict(future)

# Plot the prophet forecast
fig1 = model_prophet.plot(forecast_prophet)
plt.title("Prophet Forecast")
plt.xlabel("Date")
plt.ylabel("Value (y)")
plt.show()

"""**LSTM Forecast**"""

import numpy as np
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# use "Close" column only
c_df=df[['Close']].values

c_df

# normalize the data
scaler=MinMaxScaler()
data_scaler=scaler.fit_transform(c_df)

# create sequences for training
def create_sequences(data, time_steps=60):
    X, y = [], []
    for i in range(time_steps, len(data)):
        X.append(data[i-time_steps:i])
        y.append(data[i])
    return np.array(X), np.array(y)

X, y = create_sequences(data_scaler)

# split into train and test
split = int(0.8 * len(X))
X_train, X_test,y_train, y_test = X[:split], X[split:], y[:split], y[split:]

# build the LSTM model
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(units=50))
model.add(Dropout(0.2))
model.add(Dense(units=1))

# compile and train the LSTM model
model.compile(optimizer='adam', loss='mean_squared_error')
history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))

# make the predictions
predictions = model.predict(X_test)
predictions = scaler.inverse_transform(predictions)
actual = scaler.inverse_transform(y_test)

# plot LSTM forecast
plt.figure(figsize=(10, 6))
plt.plot(actual, label='Actual Price')
plt.plot(predictions, label='Predicted Price')
plt.title('LSTM Forecast vs Actual')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()
